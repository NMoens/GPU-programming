## Kokkos views

View = $N$-dimentional arrays

- contains
  - basic types (`int`, `float`, `double`,...)
  - `struct` of basic types
- in memory space of host or device
- memory layout can be controled, sane defaults
- managed by reference counting


## Views examples

```c++
Kokkos::View<double*> a("a", 10);                      // <1>
Kokkos::View<double[5]> b("b");                        // <2>
Kokkos::View<doucle**> c("c", 10, 15);                 // <3>
Kokkos::View<double*[20]> d("d", 10);                  // <4>
Kokkos::View<double[7][9]> e("e");                     // <5>
Kokkos::View<double***> f("f", 10, 10, 10);            // <6>
Kokkos::View<double*[13][17]> f("f", 10);              // <7>
```

1. 1D array of 10 elements, runtime
2. 1D array of 5 elements, compile time
3. 2D array of 10x15 elements, runtime
4. 2D array of 10x20 elements, rows runtime
5. 2D array of 7x9 elements, compile time
6. 3D array of 10x10x10 elements, runtime
7. 3D array of 10x13x17 elements, first dimension runtime


## Accessing views

Views can be accessed using `operator()` with indices

```c++
a(0) = 1.0;
auto x {a(1) + b(2)};
c(2, 3) = 3.0;
f(8, 9, 10) = 6.0;
```


## Views and memory spaces

- By default in the default execution space
- Can be placed in host or device memory space
  - `Kokkos::HostSpace` on host
  - `Kokkos::CudaSpace` on CUDA device
  - `Kokkos::CudaUVMSpace` in [CUDA UVM]^(Unified Virtual Memory)
  - `Kokkos::HipSpace` on HIP device

::: {.callout-warning .fragment}
Can only be accessed in execution space associated with memory space
:::


## Memory layout

Two main memory layouts

- `Kokkos::LayoutLeft` = column-major
- `Kokkos::LayoutRight` = row-major

::: {.fragment}
Example:

```c++
Kokkos::View<double**, Kokkos::LayoutLeft> a("a", 10, 15);
Kokkos::View<double**, Kokkos::LayoutRight> b("b", 10, 15);
```
:::

::: {.fragment}
Default "best" for memory space, parallel access over leftmost index
:::

- Left for device memory spaces: coalesced memory access
- Right for host memory space: cache-friendly access


## Deep copy

- Copy data between views
- Bit copy, no conversion
  - views must have the same layout and padding
- Execution space can be specified

::: {.callout-warning .fragment}
`Kokkos::deep_copy` between different memory spaces may not work
:::


## Mirror views

Required for, e.g.,

- initlizing views from file
- writing views to file
- non-paralellizable operations

::: {.fragment}
```c++
Kokkos::View<double*> a("a", 10);
auto a_host = Kokkos::create_mirror(a);             // <1>
Kokkos::deep_copy(a_host, a);                       // <2>
```

1. Create a mirror view on host
2. Copy data from device to host
:::

::: {.fragment}
Takes care of layout differences
:::


## Execution patterns

::: {.fragment}
Parallel for:
```c++
Kokkos::parallel_for(10, KOKKOS_LAMBDA(int i) {
        a(i) = i;
    });
```
:::

::: {.fragment}
Parallel reduce:
```c++
double sum {0.0};
Kokkos::parallel_reduce(10, KOKKOS_LAMBDA(int i, double& sum) {
        sum += a(i);
    }, sum);
```
:::

::: {.fragment}
Parallel scan:
```c++
Kokkos::parallel_scan(10, KOKKOS_LAMBDA(int i, double& update, bool final) {
        update += a(i);
        if (final) a(i) = update;
    });
```
:::


## Execution policies

::: {.fragment}
`Kokkos::RangePolicy` = range of indices
```c++
Kokkos::parallel_for(Kokkos::RangePolicy(0, 10),
    KOKKOS_LAMBDA(int i) {
        a(i) = i;
    });
```
:::

::: {.fragment}
`Kokkos::MDRangePolicy` = multi-dimensional range
```c++
Kokkos::parallel_for(
    Kokkos::MDRangePolicy<Kokkos::Rank<2>>({0, 0}, {10, 15}),
    KOKKOS_LAMBDA(int i, int j) {
        a(i, j) = i + j;
    });
```
:::


## Tiling

Both can be defined with chunk size

::: {.fragment}
```c++
Kokkos::parallel_for(Kokkos::RangePolicy(0, 10, 2),
    KOKKOS_LAMBDA(int i) {
        a(i) = i;
    });
```
:::

::: {.fragment}
```c++  
Kokkos::parallel_for(
    Kokkos::MDRangePolicy( {0, 0}, {10, 15}, {2, 3}),
    KOKKOS_LAMBDA(int i, int j) {
        a(i, j) = i + j;
    });
```
:::


## Execution spaces

1. `Kokkos::Cuda` = parallel execution on CUDA device
1. `Kokkos::Hip` = parallel execution on HIP device
1. `Kokkos::OpenMP` = parallel execution on host
1. `Kokkos::Serial` = serial execution on host

::: {.fragment}
Default execution space: highest enabled at compile time
:::

- `Kokkos::DefaultExecutionSpace` = default execution space
- `Kokkos::DefaultHostExecutionSpace` = default host execution space


## Using execution spaces

```c++
  Kokkos::View<int*, Kokkos::HostSpace> a("a", 10);
  Kokkos::parallel_for(Kokkos::RangePolicy<Kokkos::OpenMP>(0, 10),
      KOKKOS_LAMBDA(int i) {
          a(i) = i;
  });
```


## Functors

- Can be used instead of lambdas
- For more complex operations
- Can be reused
- Can be templated
- Have to implement some methods


## Functor for parallel for

```c++  
struct MyFunctor {
    private:
        Kokkos::View<double*> a_;                                // <1>
    public:
        explicit MyFunctor(Kokkos::View<double*> a_) : a(a_) {}  // <2>
        KOKKOS_INLINE_FUNCTION
        void operator()(const int i) const {                     // <3>
            a(i) = i;
        }
};
```

1. View(s) to operator on
2. Constructor that takes view(s), initializes state
3. `operator()` that does the work, cfr. lambda function


## Using parallel for functor

```c++
Kokkos::View<double*> a("a", 10);
Kokkos::View<double*> b("b", 10);
MyFunctor my_functor(a);                            // <1>
Kokkos::parallel_for(10, my_functor);
Kokkos::parallel_for(10, MyFunctor(b));             // <2>
```

1. Create functor with view `a` to be used multiple times
2. Create functor with view `b` and use it directly


## Functor for parallel reduce

```c++  
struct MyReduceFunctor {
    private:
        Kokkos::View<double*> a_;
    public:
        explicit MyReduceFunctor(Kokkos::View<double*> a_) : a(a_) {}
        KOKKOS_INLINE_FUNCTION
        void operator()(const int i, double& sum) const {                // <1>
            sum += a(i);
        }
        KOKKOS_INLINE_FUNCTION
        void join(double& dst, const double& src) const {                // <2>
            dst += src;
        }
};
```

1. `operator()` with accumulator
2. `join()` to combine partial results


## Using parallel reduce functor

```c++  
Kokkos::View<double*> a("a", 10);
double sum {0.0};
MyReduceFunctor my_reduce_functor(a);
Kokkos::parallel_reduce(10, my_reduce_functor, sum);
```
